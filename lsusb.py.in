#!/usr/bin/python3
# SPDX-License-Identifier: GPL-2.0 OR GPL-3.0
#
# lsusb-VERSION.py
#
# Displays your USB devices in reasonable form.
#
# Copyright (c) 2009 Kurt Garloff <garloff@suse.de>
# Copyright (c) 2013,2018 Kurt Garloff <kurt@garloff.de>
#
# Usage: See usage()

# Py2 compat
from __future__ import print_function
import getopt
import os
import re
import sys

HUB_ICLASS = 0x09

# Global options
showint = False
showhubint = False
noemptyhub = False
nohub = False
showeps = False

prefix = "/sys/bus/usb/devices/"
usbids = [
	"@usbids@",
	"/usr/share/usb.ids",
	"/usr/share/libosinfo/usb.ids",
	"/usr/share/kcmusb/usb.ids",
]

esc = chr(27)
norm = esc + "[0;0m"
bold = esc + "[0;1m"
red =  esc + "[0;31m"
green= esc + "[0;32m"
amber= esc + "[0;33m"
blue = esc + "[0;34m"

cols = ("", "", "", "", "", "")

def readattr(path, name):
	"Read attribute from sysfs and return as string"
	f = open(prefix + path + "/" + name);
	return f.readline().rstrip("\n");

def readlink(path, name):
	"Read symlink and return basename"
	return os.path.basename(os.readlink(prefix + path + "/" + name));

usbvendors = {}
usbproducts = {}
usbclasses = {}

def ishexdigit(str):
	"return True if all digits are valid hex digits"
	for dg in str:
		if not dg.isdigit() and not dg in 'abcdef':
			return False
	return True

def open_read_ign(fn):
	try:
		return open(fn, 'r', errors='ignore')
	except:
		return open(fn, 'r')

def myenum(*args):
	enums = dict(zip(args, range(len(args))))
	return type('MyEnum', (), enums)

def parse_usb_ids():
	"Parse /usr/share/usb.ids and fill usbvendors, usbproducts, usbclasses"
	vid = 0
	did = 0
	modes = myenum('Vendor', 'Class', 'Misc')
	mode = modes.Vendor
	strg = ""
	cstrg = ""
	for unm in usbids:
		if os.path.exists(unm):
			break
	for ln in open_read_ign(unm).readlines():
		if ln[0] == '#':
			continue
		ln = ln.rstrip('\n')
		if len(ln) == 0:
			continue
		if ishexdigit(ln[0:4]):
			mode = modes.Vendor
			vid = int(ln[:4], 16)
			usbvendors[vid] = ln[6:]
			continue
		if ln[0] == '\t' and ishexdigit(ln[1:3]):
			# usb.ids has a device id of 01xy, sigh
			if ln[3:5] == "xy":
				did = int(ln[1:3], 16)*256
			else:
				did = int(ln[1:5], 16)
			# USB devices
			if mode == modes.Vendor:
				usbproducts[vid, did] = ln[7:]
				continue
			elif mode == modes.Class:
				nm = ln[5:]
				if nm != "Unused":
					strg = cstrg + ":" + nm
				else:
					strg = cstrg + ":"
				usbclasses[vid, did, -1] = strg
				continue
		if ln[0] == 'C':
			mode = modes.Class
			cid = int(ln[2:4], 16)
			cstrg = ln[6:]
			usbclasses[cid, -1, -1] = cstrg
			continue
		if mode == modes.Class and ln[0] == '\t' and ln[1] == '\t' and ishexdigit(ln[2:4]):
			prid = int(ln[2:4], 16)
			usbclasses[cid, did, prid] = ln[6:]
			continue
		mode = modes.Misc
	usbclasses[0xFF, 0xFF, 0xFF] = "Vendor Specific"

def find_usb_prod(vid, pid):
	"Return device name from USB Vendor:Product list"
	strg = ""
	vendor = usbvendors.get(vid)
	if vendor:
		strg = str(vendor)
	else:
		return ""
	product = usbproducts.get((vid, pid))
	if product:
		return strg + " " + str(product)
	return strg

def find_usb_class(cid, sid, pid):
	"Return USB protocol from usbclasses list"
	lnlst = len(usbclasses)
	cls = usbclasses.get((cid, sid, pid))
	if cls:
		return str(cls)
	cls = usbclasses.get((cid, sid, -1))
	if cls:
		return str(cls)
	cls = usbclasses.get((cid, -1, -1))
	if cls:
		return str(cls)
	return ""


devlst = [
	'host',			# usb-storage
	'video4linux/video',	# uvcvideo et al.
	'sound/card',		# snd-usb-audio
	'net/',			# cdc_ether, ...
	'input/input',		# usbhid
	'usb:hiddev',		# usb hid
	'bluetooth/hci',	# btusb
	'ttyUSB',		# btusb
	'tty/',			# cdc_acm
	'usb:lp',		# usblp
	#'usb/lp',		# usblp
	'usb/',			# hiddev, usblp
	#'usbhid',		# hidraw
]

def find_storage(hostno):
	"Return SCSI block dev names for host"
	res = ""
	for ent in os.listdir("/sys/class/scsi_device/"):
		(host, bus, tgt, lun) = ent.split(":")
		if host == hostno:
			try:
				for ent2 in os.listdir("/sys/class/scsi_device/%s/device/block" % ent):
					res += ent2 + " "
			except:
				pass
	return res

def add_drv(path, drvnm):
	res = ""
	try:
		for e2 in os.listdir(path+"/"+drvnm):
			if e2[0:len(drvnm)] == drvnm:
				res += e2 + " "
		try:
			if res:
				res += "(" + os.path.basename(os.readlink(path+"/driver")) + ") "
		except:
			pass
	except:
		pass
	return res

def find_dev(driver, usbname):
	"Return pseudo devname that's driven by driver"
	res = ""
	for nm in devlst:
		dirnm = prefix + usbname
		prep = ""
		idx = nm.find('/')
		if idx != -1:
			prep = nm[:idx+1]
			dirnm += "/" + nm[:idx]
			nm = nm[idx+1:]
		ln = len(nm)
		try:
			for ent in os.listdir(dirnm):
				if ent[:ln] == nm:
					res += prep+ent+" "
					if nm == "host":
						res += "(" + find_storage(ent[ln:])[:-1] + ")"
		except:
			pass
	if driver == "usbhid":
		rg = re.compile(r'[0-9A-F]{4}:[0-9A-F]{4}:[0-9A-F]{4}\.[0-9A-F]{4}')
		for ent in os.listdir(prefix + usbname):
			m = rg.match(ent)
			if m:
				res += add_drv(prefix+usbname+"/"+ent, "hidraw")
				add = add_drv(prefix+usbname+"/"+ent, "input")
				if add:
					res += add
				else:
					for ent2 in os.listdir(prefix+usbname+"/"+ent):
						m = rg.match(ent2)
						if m:
							res += add_drv(prefix+usbname+"/"+ent+"/"+ent2, "input")
	return res


class UsbEndpoint:
	"Container for USB endpoint info"
	def __init__(self, parent, fname, level):
		self.parent = parent
		self.level = level
		self.fname = fname
		self.epaddr = 0
		self.len = 0
		self.ival = ""
		self.type = ""
		self.attr = 0
		self.max = 0
		if self.fname:
			self.read(self.fname)

	def read(self, fname):
		fullpath = ""
		if self.parent:
			fullpath = self.parent.fullpath + "/"
		fullpath += fname
		self.epaddr = int(readattr(fullpath, "bEndpointAddress"), 16)
		ival = int(readattr(fullpath, "bInterval"), 16)
		if ival:
			self.ival = "(%s)" % readattr(fullpath, "interval")
		self.len = int(readattr(fullpath, "bLength"), 16)
		self.type = readattr(fullpath, "type")
		self.attr = int(readattr(fullpath, "bmAttributes"), 16)
		self.max = int(readattr(fullpath, "wMaxPacketSize"), 16)

	def __str__(self):
		indent = self.level + len(self.parent.fname)
		return "%-17s  %s(EP) %02x: %s %s attr %02x len %02x max %03x%s\n" % \
			(" " * indent, cols[5], self.epaddr, self.type,
			 self.ival, self.attr, self.len, self.max, cols[0])


class UsbInterface:
	"Container for USB interface info"
	def __init__(self, parent, fname, level=1):
		self.parent = parent
		self.level = level
		self.fullpath = ""
		self.fname = fname
		self.iclass = 0
		self.isclass = 0
		self.iproto = 0
		self.noep = 0
		self.driver = ""
		self.devname = ""
		self.protoname = ""
		self.eps = []
		if self.fname:
			self.read(self.fname)

	def read(self, fname):
		fullpath = ""
		if self.parent:
			fullpath += self.parent.fname + "/"
		fullpath += fname
		self.fullpath = fullpath
		self.fname = fname
		self.iclass = int(readattr(fullpath, "bInterfaceClass"),16)
		self.isclass = int(readattr(fullpath, "bInterfaceSubClass"),16)
		self.iproto = int(readattr(fullpath, "bInterfaceProtocol"),16)
		self.noep = int(readattr(fullpath, "bNumEndpoints"))
		try:
			self.driver = readlink(fname, "driver")
			self.devname = find_dev(self.driver, fname)
		except:
			pass
		self.protoname = find_usb_class(self.iclass, self.isclass, self.iproto)
		if showeps:
			for dirent in os.listdir(prefix + fullpath):
				if dirent[:3] == "ep_":
					ep = UsbEndpoint(self, dirent, self.level+1)
					self.eps.append(ep)

	def __str__(self):
		if self.noep == 1:
			plural = " "
		else:
			plural = "s"
		strg = "%-17s (IF) %02x:%02x:%02x %iEP%s (%s) %s%s %s%s%s\n" % \
			(" " * self.level+self.fname, self.iclass,
			 self.isclass, self.iproto, self.noep,
			 plural, self.protoname, 
			 cols[3], self.driver,
			 cols[4], self.devname, cols[0])
		if showeps and self.eps:
			for ep in self.eps:
				strg += str(ep)
		return strg

class UsbDevice:
	"Container for USB device info"
	def __init__(self, parent, fname, level=0):
		self.parent = parent
		self.level = level
		self.fname = fname
		self.fullpath = ""
		self.iclass = 0
		self.isclass = 0
		self.iproto = 0
		self.vid = 0
		self.pid = 0
		self.name = ""
		self.usbver = ""
		self.speed = ""
		self.maxpower = ""
		self.noports = 0
		self.nointerfaces = 0
		self.driver = ""
		self.devname = ""
		self.interfaces = []
		self.children = []
		if self.fname:
			self.read(self.fname)
			self.readchildren()

	def read(self, fname):
		self.fname = fname
		self.fullpath = fname
		self.iclass = int(readattr(fname, "bDeviceClass"), 16)
		self.isclass = int(readattr(fname, "bDeviceSubClass"), 16)
		self.iproto = int(readattr(fname, "bDeviceProtocol"), 16)
		self.vid = int(readattr(fname, "idVendor"), 16)
		self.pid = int(readattr(fname, "idProduct"), 16)
		try:
			self.name = readattr(fname, "manufacturer") + " " \
				  + readattr(fname, "product")
		except:
			pass
		if self.name and self.name[:5] == "Linux":
			mch = re.match(r"Linux [^ ]* (.hci[_-]hcd) .HCI Host Controller", self.name)
			if mch:
				self.name = mch.group(1)
		if not self.name:
			self.name = find_usb_prod(self.vid, self.pid)
		# Some USB Card readers have a better name then Generic ...
		if self.name[:7] == "Generic":
			oldnm = self.name
			self.name = find_usb_prod(self.vid, self.pid)
			if not self.name:
				self.name = oldnm
		try:
			ser = readattr(fname, "serial")
			# Some USB devs report "serial" as serial no. suppress
			if (ser and ser != "serial"):
				self.name += " " + ser
		except:
			pass
		self.usbver = readattr(fname, "version")
		self.speed = readattr(fname, "speed")
		self.maxpower = readattr(fname, "bMaxPower")
		self.noports = int(readattr(fname, "maxchild"))
		try:
			self.nointerfaces = int(readattr(fname, "bNumInterfaces"))
		except:
			self.nointerfaces = 0
		try:
			self.driver = readlink(fname, "driver")
			self.devname = find_dev(self.driver, fname)
		except:
			pass

	def readchildren(self):
		if self.fname[0:3] == "usb":
			fname = self.fname[3:]
		else:
			fname = self.fname
		for dirent in os.listdir(prefix + self.fname):
			if not dirent[0:1].isdigit():
				continue
			if os.access(prefix + dirent + "/bInterfaceClass", os.R_OK):
				iface = UsbInterface(self, dirent, self.level+1)
				self.interfaces.append(iface)
			else:
				usbdev = UsbDevice(self, dirent, self.level+1)
				self.children.append(usbdev)
		usbsortkey = lambda obj: [int(x) for x in re.split(r"[-:.]", obj.fname)]
		self.interfaces.sort(key=usbsortkey)
		self.children.sort(key=usbsortkey)

	def __str__(self):
		if self.iclass == HUB_ICLASS:
			col = cols[2]
			if noemptyhub and len(self.children) == 0:
				return ""
			if nohub:
				strg = ""
		else:
			col = cols[1]
		if not nohub or self.iclass != HUB_ICLASS:
			if self.nointerfaces == 1:
				plural = " "
			else:
				plural = "s"
			strg = "%-16s %s%04x:%04x%s %02x %s%6sMbit/s %5s %iIF%s (%s%s%s)" % \
				(" " * self.level + self.fname, 
				 cols[1], self.vid, self.pid, cols[0],
				 self.iclass, self.usbver, self.speed, self.maxpower,
				 self.nointerfaces, plural, col, self.name, cols[0])
			if self.iclass == HUB_ICLASS and not showhubint:
				strg += " %shub%s\n" % (cols[2], cols[0])
			else:
				strg += "\n"
				if showeps:
					ep = UsbEndpoint(self, "ep_00", self.level+1)
					strg += str(ep)
				if showint:	
					for iface in self.interfaces:
						strg += str(iface)
		for child in self.children:
			strg += str(child)
		return strg


def usage():
	"Displays usage information"
	print("Usage: lsusb.py [options]")
	print()
	print("Options:")
	print("  -h, --help            display this help")
	print("  -i, --interfaces      display interface information")
	print("  -I, --hub-interfaces  display interface information, even for hubs")
	print("  -u, --hide-empty-hubs suppress empty hubs")
	print("  -U, --hide-hubs       suppress all hubs")
	print("  -c, --color           use colors")
	print("  -e, --endpoints       display endpoint info")
	print("  -f FILE, --usbids-path FILE")
	print("                        override filename for /usr/share/usb.ids")
	print()
	print("Use lsusb.py -ciu to get a nice overview of your USB devices.")

def read_usb():
	"Read toplevel USB entries and print"
	root_hubs = []
	for dirent in os.listdir(prefix):
		if not dirent[0:3] == "usb":
			continue
		usbdev = UsbDevice(None, dirent, 0)
		root_hubs.append(usbdev)
	root_hubs.sort(key=lambda x: int(x.fname[3:]))
	for usbdev in root_hubs:
		print(usbdev, end="")

def main(argv):
	"main entry point"
	global showint, showhubint, noemptyhub, nohub
	global cols, usbids, showeps

	long_options = [
		"help",
		"interfaces",
		"hub-interfaces",
		"hide-empty-hubs",
		"hide-hubs",
		"color",
		"usbids-path=",
		"endpoints",
	]

	try:
		(optlist, args) = getopt.gnu_getopt(argv[1:], "hiIuUwcef:", long_options)
	except getopt.GetoptError as exc:
		print("Error:", exc, file=sys.stderr)
		sys.exit(2)
	for opt in optlist:
		if opt[0] in {"-h", "--help"}:
			usage()
			sys.exit(0)
		elif opt[0] in {"-i", "--interfaces"}:
			showint = True
		elif opt[0] in {"-I", "--hub-interfaces"}:
			showint = True
			showhubint = True
		elif opt[0] in {"-u", "--hide-empty-hubs"}:
			noemptyhub = True
		elif opt[0] in {"-U", "--hide-hubs"}:
			noemptyhub = True
			nohub = True
		elif opt[0] in {"-c", "--color"}:
			cols = (norm, bold, red, green, amber, blue)
		elif opt[0] == "-w":
			print("Warning: option -w is no longer supported", file=sys.stderr)
		elif opt[0] in {"-f", "--usbids-path"}:
			usbids = [opt[1]]
		elif opt[0] in {"-e", "--endpoints"}:
			showeps = True
	if len(args) > 0:
		print("Error: excess args %s ..." % args[0], file=sys.stderr)
		sys.exit(2)

	if usbids[0]:
		try:
			parse_usb_ids()
		except:
			print(" WARNING: Failure to read usb.ids", file=sys.stderr)
			#print(sys.exc_info(), file=sys.stderr)
	read_usb()

# Entry point
if __name__ == "__main__":
	main(sys.argv)


